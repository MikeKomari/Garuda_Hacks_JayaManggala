import"dotenv/config";import Fe from"chalk";import z from"express";import Ve from"cors";import{Router as He}from"express";import{Router as xe}from"express";var t=class o extends Error{statusCode;status;operational;constructor(a,n){super(a),this.statusCode=n,this.status=n.toString().startsWith("2")?"success":"fail",this.operational=!0,Object.setPrototypeOf(this,o.prototype),Error.captureStackTrace(this,this.constructor)}};var N=process.env.ENVIROMENT==="PROD",X=async(o,a,n,e)=>{if(o instanceof t){n.status(o.statusCode).send({status:o.status,statusCode:o.statusCode,message:o.message,...N?{}:{stack:o.stack}});return}n.status(500).send({status:"fail",statusCode:500,message:"Oops, Something went very wrong!",...N?{}:{stack:o.stack}})},C=X;import{PrismaClient as ee}from"@prisma/client";var i=new ee,H=process.env.JWT_SECRET,Ze=process.env.JWT_EXPIRES_IN;var r={OK:200,CREATED:201,BAD_REQUEST:400,UNAUTHORIZED:401,FORBIDDEN:403,NOT_FOUND:404,INTERNAL_SERVER_ERROR:500};import V from"bcrypt";import te from"jsonwebtoken";var D=o=>{let a={id:o.id,email:o.email,role:o.role||"user"};return te.sign(a,H,{expiresIn:"1d"})};import re from"axios";var oe=async(o,a,n)=>{try{let e=o.body.token;if(!e)throw new t("Token is required",r.BAD_REQUEST);let s=await re.get(`https://www.googleapis.com/oauth2/v3/userinfo?token=${e}`),d=await i.user.findUnique({where:{email:s.data.email}});if(d)throw new t("User already exists",r.BAD_REQUEST);let c;d?c=d:c=await i.user.create({data:{name:s.data.name,email:s.data.email,password:"",role:"User"}});let u=D(c);if(!u)throw new t("Failed to create JWT token",r.INTERNAL_SERVER_ERROR);a.send({message:"User logged in successfully",data:c,token:u})}catch(e){n(e)}},ae=async(o,a,n)=>{try{let{email:e,password:s,name:d,age:c,username:u}=o.body;if(await i.user.findUnique({where:{email:e||null}}))throw new t("User already exists",r.BAD_REQUEST);if(await i.user.findUnique({where:{username:u||null}}))throw new t("Username already exists",r.BAD_REQUEST);let h=await V.hash(s,10);if(!c||c<0)throw new t("Invalid age",r.BAD_REQUEST);let f=await i.user.create({data:{email:e,password:h,name:d,age:c,username:u,hearts:3,streak:0,membership:{create:{type:"Free",status:"Inactive"}}}}),l=D(f);if(!l)throw new t("Failed to create JWT token",r.INTERNAL_SERVER_ERROR);a.send({message:"User created successfully",data:f,token:l})}catch(e){n(e)}},ne=async(o,a,n)=>{try{let{username:e,password:s}=o.body;if(!e||!s)throw new t("Username and password are required",r.BAD_REQUEST);let d=await i.user.findUnique({where:{username:e}});if(!d)throw new t("User not found",r.NOT_FOUND);if(!await V.compare(s,d.password))throw new t("Invalid password",r.UNAUTHORIZED);let u=D(d);if(!u)throw new t("Failed to create JWT token",r.INTERNAL_SERVER_ERROR);a.send({message:"User logged in successfully",data:d,token:u})}catch(e){n(e)}},q={registerUser:ae,loginGoogle:oe,loginUser:ne};var se=async(o,a,n)=>{try{let{title:e,regionId:s,originalText:d,englishText:c,vocab:u}=o.body;if(!e)throw new t("Story title is required",r.BAD_REQUEST);if(!s)throw new t("Region ID is required",r.BAD_REQUEST);if(!d)throw new t("Original text is required",r.BAD_REQUEST);if(!c)throw new t("English text is required",r.BAD_REQUEST);if(u){if(!Array.isArray(u))throw new t("Vocabularies must be an array",r.BAD_REQUEST);for(let h of u)if(!h.vocabText||!h.translatedText||!h.pronouncation)throw new t("Each vocabulary entry must have vocabText, translatedText, and pronouncation",r.BAD_REQUEST)}if(!await i.region.findUnique({where:{id:s}}))throw new t("Region not found",r.NOT_FOUND);let w=await i.story.create({data:{title:e,regionId:s,originalText:d,englishText:c,vocab:{create:u.map(h=>({vocabText:h.vocabText,translatedText:h.translatedText,pronouncation:h.pronouncation,regionId:s}))}},include:{vocab:!0}});a.send({message:"Story created successfully",data:w})}catch(e){n(e)}},ie=async(o,a,n)=>{try{let{id:e}=o.params;if(!e)throw new t("Story ID is required",r.BAD_REQUEST);let{title:s,regionId:d,originalText:c,englishText:u,vocab:p}=o.body;if(!s)throw new t("Story title is required",r.BAD_REQUEST);if(!d)throw new t("Region ID is required",r.BAD_REQUEST);if(!c)throw new t("Original text is required",r.BAD_REQUEST);if(!u)throw new t("English text is required",r.BAD_REQUEST);if(p){if(!Array.isArray(p))throw new t("Vocabularies must be an array",r.BAD_REQUEST);for(let l of p)if(!l.vocabText||!l.translatedText||!l.pronouncation)throw new t("Each vocabulary entry must have vocabText, translatedText, and pronouncation",r.BAD_REQUEST)}let w=await i.story.findUnique({where:{id:e}});if(!w)throw new t("Story not found",r.NOT_FOUND);if(!await i.region.findUnique({where:{id:d}}))throw new t("Region not found",r.NOT_FOUND);let f=await i.story.update({where:{id:e},data:{title:s??w.title,regionId:d??w.regionId,originalText:c??w.originalText,englishText:u??w.englishText,vocab:p?{upsert:p.map(l=>({where:{id:l.id??""},update:{vocabText:l.vocabText,translatedText:l.translatedText,pronouncation:l.pronouncation,regionId:d??w.regionId},create:{vocabText:l.vocabText,translatedText:l.translatedText,pronouncation:l.pronouncation,regionId:d??w.regionId}}))}:void 0},include:{vocab:!0}});a.send({message:"Story updated successfully",data:f})}catch(e){n(e)}},de=async(o,a,n)=>{try{let e=await i.story.findMany({orderBy:{createdAt:"desc"},include:{region:!0}});if(!e||e.length===0)throw new t("No stories found",r.NOT_FOUND);a.send({message:"Stories retrieved successfully",data:e})}catch(e){n(e)}},ce=async(o,a,n)=>{try{let{id:e}=o.params;if(!e)throw new t("Story ID is required",r.BAD_REQUEST);let s=await i.story.findUnique({where:{id:e},include:{region:!0,vocab:!0}});if(!s)throw new t("Story not found",r.NOT_FOUND);a.send({message:"Story retrieved successfully",data:s})}catch(e){n(e)}},ue=async(o,a,n)=>{try{let{id:e}=o.params;if(!e)throw new t("Story ID is required",r.BAD_REQUEST);if(!await i.story.findUnique({where:{id:e}}))throw new t("Story not found",r.NOT_FOUND);await i.story.delete({where:{id:e}}),a.send({message:"Story deleted successfully"})}catch(e){n(e)}},g={createStory:se,editStory:ie,getStory:de,getStoryById:ce,deleteStory:ue};var le=async(o,a,n)=>{try{let{name:e}=o.body;if(!e)throw new t("Region name is required",r.BAD_REQUEST);let s=await i.region.create({data:{name:e}});a.send({message:"Region created successfully",data:s})}catch(e){n(e)}},pe=async(o,a,n)=>{try{let{id:e}=o.params;if(!e)throw new t("Region ID is required",r.BAD_REQUEST);let{name:s}=o.body;if(!s)throw new t("Region name is required",r.BAD_REQUEST);let d=o.body.payload.id,c=await i.user.findUnique({where:{id:d}});if(!c||c.role!=="Admin")throw new t("Unauthorized",r.UNAUTHORIZED);if(!await i.region.findUnique({where:{id:e}}))throw new t("Region not found",r.NOT_FOUND);let p=await i.region.update({where:{id:e},data:{name:s}});a.send({message:"Region updated successfully",data:p})}catch(e){n(e)}},we=async(o,a,n)=>{try{let{id:e}=o.params;if(!e)throw new t("Region ID is required",r.BAD_REQUEST);let s=o.body.payload.id,d=await i.user.findUnique({where:{id:s}});if(!d||d.role!=="Admin")throw new t("Unauthorized",r.UNAUTHORIZED);if(!await i.region.findUnique({where:{id:e}}))throw new t("Region not found",r.NOT_FOUND);let u=await i.region.delete({where:{id:e}});a.send({message:"Region deleted successfully",data:u})}catch(e){n(e)}},he=async(o,a,n)=>{try{let e=await i.region.findMany({orderBy:{name:"desc"}});a.send({message:"Regions retrieved successfully",data:e})}catch(e){n(e)}},fe=async(o,a,n)=>{try{let{id:e}=o.params;if(!e)throw new t("Region ID is required",r.BAD_REQUEST);let s=await i.region.findUnique({where:{id:e}});if(!s)throw new t("Region not found",r.NOT_FOUND);a.send({message:"Region retrieved successfully",data:s})}catch(e){n(e)}},R={createRegion:le,editRegion:pe,deleteRegion:we,getRegions:he,getRegionById:fe};var me=async(o,a,n)=>{try{let{vocabText:e,translatedText:s,pronouncation:d,regionId:c}=o.body;if(!e)throw new t("Vocab text is required",r.BAD_REQUEST);if(!s)throw new t("Translated text is required",r.BAD_REQUEST);if(!d)throw new t("Pronouncation is required",r.BAD_REQUEST);if(!c)throw new t("Region ID is required",r.BAD_REQUEST);let u=o.body.payload.id,p=await i.user.findUnique({where:{id:u}});if(!p||p.role!=="Admin")throw new t("Unauthorized",r.UNAUTHORIZED);if(!await i.region.findUnique({where:{id:c}}))throw new t("Region not found",r.NOT_FOUND);let h=await i.vocabulary.create({data:{vocabText:e,translatedText:s,pronouncation:d,regionId:c}});a.send({message:"Vocabulary created successfully",data:h})}catch(e){n(e)}},ge=async(o,a,n)=>{try{let{id:e}=o.params;if(!e)throw new t("Vocab ID is required",r.BAD_REQUEST);let{vocabText:s,translatedText:d,pronouncation:c,regionId:u}=o.body;if(!s)throw new t("Vocab text is required",r.BAD_REQUEST);if(!d)throw new t("Translated text is required",r.BAD_REQUEST);if(!c)throw new t("Pronouncation is required",r.BAD_REQUEST);if(!u)throw new t("Region ID is required",r.BAD_REQUEST);let p=o.body.payload.id,w=await i.user.findUnique({where:{id:p}});if(!w||w.role!=="Admin")throw new t("Unauthorized",r.UNAUTHORIZED);if(!await i.region.findUnique({where:{id:u}}))throw new t("Region not found",r.NOT_FOUND);let f=await i.vocabulary.create({data:{vocabText:s,translatedText:d,pronouncation:c,regionId:u}});a.send({message:"Vocabulary created successfully",data:f})}catch(e){n(e)}},ye=async(o,a,n)=>{try{let e=await i.vocabulary.findMany({include:{region:!0}});a.send({message:"Vocab retrieved successfully",data:e})}catch(e){n(e)}},Re=async(o,a,n)=>{try{let{regionId:e}=o.params;if(!e)throw new t("Region ID is required",r.BAD_REQUEST);let s=await i.vocabulary.findMany({where:{regionId:e},include:{region:!0}});if(s.length===0)throw new t("No vocab found for this region",r.NOT_FOUND);a.send({message:"Vocab retrieved successfully",data:s})}catch(e){n(e)}},Te=async(o,a,n)=>{try{let{id:e}=o.params;if(!e)throw new t("Vocab ID is required",r.BAD_REQUEST);let s=o.body.payload.id,d=await i.user.findUnique({where:{id:s}});if(!d||d.role!=="Admin")throw new t("Unauthorized",r.UNAUTHORIZED);if(!await i.vocabulary.findUnique({where:{id:e}}))throw new t("Vocab not found",r.NOT_FOUND);await i.vocabulary.delete({where:{id:e}}),a.send({message:"Vocab deleted successfully"})}catch(e){n(e)}},T={createVocab:me,editVocab:ge,getVocab:ye,getVocabByRegion:Re,deleteVocab:Te};var Ee=async(o,a,n)=>{try{let{text:e,type:s,subChapterId:d,questionOrder:c,answers:u,vocab:p}=o.body;if(!e)throw new t("Question text is required",r.BAD_REQUEST);if(!s||!["Text","Speech"].includes(s))throw new t("Valid question type (Text or Speech) is required",r.BAD_REQUEST);if(!d)throw new t("SubChapter ID is required",r.BAD_REQUEST);if(!c||c<1)throw new t("Valid question order is required",r.BAD_REQUEST);if(!u||!Array.isArray(u)||u.length<1)throw new t("At least one answer is required",r.BAD_REQUEST);let w=0;for(let l of u){if(!l.text)throw new t("Each answer must have text",r.BAD_REQUEST);l.isCorrect&&w++}if(w!==1)throw new t("Exactly one answer must be correct",r.BAD_REQUEST);if(p){if(!Array.isArray(p))throw new t("Vocabularies must be an array",r.BAD_REQUEST);for(let l of p)if(!l.vocabText||!l.translatedText||!l.pronunciation)throw new t("Each vocabulary entry must have vocabText, translatedText, and pronunciation",r.BAD_REQUEST)}let h=await i.subChapter.findUnique({where:{id:d},include:{chapter:{include:{story:{include:{region:!0}}}}}});if(!h)throw new t("SubChapter not found",r.NOT_FOUND);let f=await i.question.create({data:{text:e,type:s,subChapterId:d,questionOrder:c,answer:{create:u.map(l=>({text:l.text,isCorrect:l.isCorrect}))},vocab:{create:p?.map(l=>({vocabText:l.vocabText,translatedText:l.translatedText,pronunciation:l.pronunciation,regionId:h.chapter.story.regionId}))}},include:{answer:!0,vocab:!0}});a.send({message:"Question created successfully",data:f})}catch(e){n(e)}},Ue=async(o,a,n)=>{try{let{id:e}=o.params,s=await i.question.findUnique({where:{id:e},include:{answer:!0,vocab:!0}});if(!s)throw new t("Question not found",r.NOT_FOUND);a.send({message:"Question retrieved successfully",data:s})}catch(e){n(e)}},be=async(o,a,n)=>{try{let e=await i.question.findMany({include:{subChapter:{include:{chapter:{include:{story:!0}}}},answer:!0,vocab:!0},orderBy:{questionOrder:"asc"}});a.send({message:"Questions retrieved successfully",data:e})}catch(e){n(e)}},qe=async(o,a,n)=>{try{let{id:e}=o.params,{text:s,type:d,questionOrder:c}=o.body,u=await i.question.findUnique({where:{id:e}});if(!u)throw new t("Question not found",r.NOT_FOUND);if(!s&&!d&&!c)throw new t("At least one field (text, type, or questionOrder) is required",r.BAD_REQUEST);if(d&&!["Text","Speech"].includes(d))throw new t("Valid question type (Text or Speech) is required",r.BAD_REQUEST);if(c&&c<1)throw new t("Valid question order is required",r.BAD_REQUEST);let p=await i.question.update({where:{id:e},data:{text:s||u.text,type:d||u.type,questionOrder:c||u.questionOrder}});a.send({message:"Question updated successfully",data:p})}catch(e){n(e)}},Se=async(o,a,n)=>{try{let{id:e}=o.params;if(!await i.question.findUnique({where:{id:e}}))throw new t("Question not found",r.NOT_FOUND);await i.question.delete({where:{id:e}}),a.send({message:"Question deleted successfully"})}catch(e){n(e)}},y={createQuestion:Ee,getQuestionById:Ue,getAllQuestion:be,updateQuestion:qe,deleteQuestion:Se};var _=xe();_.post("/register",q.registerUser);_.post("/login-google",q.loginGoogle);_.post("/login",q.loginUser);var F=_;import{Router as Ae}from"express";var S=Ae();S.get("/region",R.getRegions);S.post("/region",R.createRegion);S.post("/region/update/:id",R.editRegion);S.post("/region/delete/:id",R.deleteRegion);var k=S;import{Router as De}from"express";var E=De();E.get("/story",g.getStory);E.get("/story/:id",g.getStoryById);E.post("/story",g.createStory);E.post("/story/update/:id",g.editStory);E.post("/story/delete/:id",g.deleteStory);var P=E;import{Router as _e}from"express";var x=_e();x.get("/vocab",T.getVocab);x.get("/vocab/:regionId",T.getVocabByRegion);x.post("/vocab/create",T.createVocab);x.post("/vocab/edit/:id",T.editVocab);var W=x;import{Router as Ce}from"express";var U=Ce();U.get("/question",y.getAllQuestion);U.get("/question/:id",y.getQuestionById);U.post("/question",y.createQuestion);U.post("/update/question/:id",y.updateQuestion);U.post("/delete/question/:id",y.deleteQuestion);var j=U;import{Router as Qe}from"express";import O from"axios";import J from"fs-extra";import Oe from"openai";var v="https://api.assemblyai.com",I={authorization:process.env.ASSEMBLY_API_KEY},ve=new Oe({apiKey:process.env.OPENAI_API_KEY}),Ie=async(o,a,n)=>{try{if(!o.file)throw new t("No audio file uploaded",400);let e=o.file.path,s=o.body.ori,d=await J.readFile(e),p={audio_url:(await O.post(`${v}/v2/upload`,d,{headers:{...I,"Content-Type":"application/octet-stream"}})).data.upload_url,speech_model:"universal",language_code:"jw"},h=(await O.post(`${v}/v2/transcript`,p,{headers:I})).data.id,f=`${v}/v2/transcript/${h}`,Y=await(async()=>{for(;;){let A=(await O.get(f,{headers:I})).data;if(A.status==="completed")return A.text;if(A.status==="error")throw new Error(A.error);await new Promise(G=>setTimeout(G,3e3))}})();if(await J.remove(e),!process.env.OPENAI_API_KEY)throw new t("OpenAI API key is not set",500);let B=await(await ve.chat.completions.create({model:"gpt-4o-mini",messages:[{role:"user",content:[{type:"text",text:`Fi am currently learning speaking javanese, this is the text that I am reading

`+s+`So i read it and use an AI to transcribe it and returne

`+Y+`

 please rate how my speaking out of 100 and give me one sentence on my performance like how well i do, please dont be too harsh. return and limit your response in a json format where

{
                    "score": number
                    "comments": string 
                     
                  }
                  return without any further quotation just direct json format`}]}],temperature:1,max_tokens:2048,top_p:1})).choices[0].message.content;if(!B)throw new t("No scoring received from AI",500);a.send({message:"Scored successfully",data:B})}catch(e){n(e)}},M={checkPronounciation:Ie};import Be from"multer";var K=Qe(),Ne=Be({dest:"uploads/"});K.post("/checkVocal",Ne.single("audio"),M.checkPronounciation);var Z=K;var m=He();m.get("/",(o,a)=>{a.send({message:"Welcome API"})});m.use("/auth",F);m.use("/region",k);m.use("/story",P);m.use("/vocab",W);m.use("/question",j);m.use("/vocal",Z);var $=m;var b=z();b.use(Ve());b.use(z.json());b.use("/api",$);b.use("*",(o,a,n)=>{n(new t("Route not found",r.NOT_FOUND))});b.use(C);var L=b;var Q=process.env.PORT||"";L.listen(Q,()=>{console.log(`${Fe.blue("[SERVER]")} Running on Port ${Q}`)});
//# sourceMappingURL=index.mjs.map