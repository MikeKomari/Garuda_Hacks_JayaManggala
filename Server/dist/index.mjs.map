{"version":3,"sources":["../src/index.ts","../src/app.ts","../src/routes/index.ts","../src/routes/authRouter.ts","../src/utils/http/AppError.ts","../src/controllers/ErrorController.ts","../src/config/config.ts","../src/utils/http/statusCodes.ts","../src/controllers/AuthController.ts","../src/utils/helper.ts","../src/controllers/StoryController.ts","../src/controllers/RegionController.ts","../src/controllers/vocabController.ts","../src/controllers/questionController.ts","../src/routes/regionRouter.ts","../src/routes/storyRouter.ts","../src/routes/vocabRouter.ts","../src/routes/questionRouter.ts","../src/routes/vocalRouter.ts","../src/controllers/vocalController.ts","../src/config/env.ts"],"sourcesContent":["import \"dotenv/config\";\r\n\r\nimport chalk from \"chalk\";\r\nimport app from \"./app\";\r\nimport { PORT } from \"./config/env\";\r\n\r\napp.listen(PORT, () => {\r\n  console.log(`${chalk.blue(\"[SERVER]\")} Running on Port ${PORT}`);\r\n});\r\n","import express from \"express\";\r\nimport cors from \"cors\";\r\nimport router from \"./routes\";\r\nimport { AppError } from \"./utils/http/AppError\";\r\nimport { STATUS } from \"./utils/http/statusCodes\";\r\nimport { ErrorController } from \"./controllers\";\r\n\r\nconst app = express();\r\n\r\napp.use(cors());\r\n\r\napp.use(express.json());\r\n\r\napp.use(\"/api\", router);\r\n\r\napp.use(\"*\", (_, __, next) => {\r\n  next(new AppError(\"Route not found\", STATUS.NOT_FOUND));\r\n});\r\napp.use(ErrorController);\r\n\r\nexport default app;\r\n","import { Router } from \"express\";\r\nimport authRouter from \"./authRouter\";\r\nimport regionRouter from \"./regionRouter\";\r\nimport storyRouter from \"./storyRouter\";\r\nimport vocabRouter from \"./vocabRouter\";\r\nimport featureRouter from \"./featureRouter\";\r\nimport questionRouter from \"./questionRouter\";\r\nimport vocalRouter from \"./vocalRouter\";\r\n\r\nconst router = Router();\r\n\r\nrouter.get(\"/\", (_, response) => {\r\n  response.send({\r\n    message: \"Welcome API\",\r\n  });\r\n});\r\n\r\nrouter.use(\"/auth\", authRouter);\r\nrouter.use(\"/region\", regionRouter);\r\nrouter.use(\"/story\", storyRouter);\r\nrouter.use(\"/vocab\", vocabRouter);\r\nrouter.use(\"/question\", questionRouter);\r\nrouter.use(\"/vocal\", vocalRouter);\r\nexport default router;\r\n","import { Router } from \"express\";\r\nimport { AuthController } from \"../controllers\";\r\n\r\nconst authRouter = Router();\r\n\r\nauthRouter.post(\"/register\", AuthController.registerUser);\r\nauthRouter.post(\"/login-google\", AuthController.loginGoogle);\r\nauthRouter.post(\"/login\", AuthController.loginUser);\r\n\r\nexport default authRouter;\r\n","/**\r\n * Wrapper class over the error class to accomodate for API needs.\r\n * @example throw new AppError(\"Couldn't find user\", STATUS.NOT_FOUND)\r\n */\r\nexport class AppError extends Error {\r\n  statusCode: number;\r\n  status: \"fail\" | \"success\";\r\n  operational: boolean;\r\n\r\n  constructor(message: string, statusCode: number) {\r\n    super(message);\r\n\r\n    this.statusCode = statusCode;\r\n    this.status = statusCode.toString().startsWith(\"2\") ? \"success\" : \"fail\";\r\n    this.operational = true;\r\n\r\n    /**\r\n     *\r\n     * The code below is used to instanceof can be used with this class.\r\n     *\r\n     * The babel transpiler has issues when converting ES6 classes to older versions casing `instanceof` to not recognize their class. To handle we have to manually set the prototype of this class as `Error` (accessed through `AppError.prototype` which strangely works)\r\n     */\r\n    Object.setPrototypeOf(this, AppError.prototype);\r\n    Error.captureStackTrace(this, this.constructor);\r\n  }\r\n}\r\n","import { AppError } from \"../utils/http/AppError\";\r\nimport { ErrorRequestHandler } from \"express\";\r\n\r\nconst IS_PRODUCTION = process.env.ENVIROMENT === \"PROD\";\r\n\r\nconst errorHandler: ErrorRequestHandler = async (\r\n  error: AppError | Error,\r\n  _,\r\n  response,\r\n  __\r\n) => {\r\n  if (error instanceof AppError) {\r\n    response.status(error.statusCode).send({\r\n      status: error.status,\r\n      statusCode: error.statusCode,\r\n      message: error.message,\r\n      ...(IS_PRODUCTION ? {} : { stack: error.stack }),\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  response.status(500).send({\r\n    status: \"fail\",\r\n    statusCode: 500,\r\n    message: \"Oops, Something went very wrong!\",\r\n    ...(IS_PRODUCTION ? {} : { stack: error.stack }),\r\n  });\r\n};\r\n\r\nexport default errorHandler;\r\n","import { PrismaClient } from \"@prisma/client\";\r\n\r\nexport const prisma = new PrismaClient();\r\nexport const JWT_SECRET = process.env.JWT_SECRET as string;\r\nexport const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN;\r\n","export const STATUS = {\r\n  OK: 200,\r\n  CREATED: 201,\r\n  BAD_REQUEST: 400,\r\n  UNAUTHORIZED: 401,\r\n  FORBIDDEN: 403,\r\n  NOT_FOUND: 404,\r\n  INTERNAL_SERVER_ERROR: 500,\r\n} as const;\r\n","import { RequestHandler } from \"express\";\r\nimport { prisma } from \"../config/config\";\r\nimport { AppError } from \"../utils/http/AppError\";\r\nimport { STATUS } from \"../utils/http/statusCodes\";\r\nimport bcrypt from \"bcrypt\";\r\nimport { createJWT } from \"../utils/helper\";\r\nimport axios from \"axios\";\r\n\r\nconst loginGoogle: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const token = request.body.token;\r\n    if (!token) {\r\n      throw new AppError(\"Token is required\", STATUS.BAD_REQUEST);\r\n    }\r\n    const userData = await axios.get(\r\n      `https://www.googleapis.com/oauth2/v3/userinfo?token=${token}`\r\n    );\r\n\r\n    const existingUser = await prisma.user.findUnique({\r\n      where: {\r\n        email: userData.data.email,\r\n      },\r\n    });\r\n\r\n    if (existingUser)\r\n      throw new AppError(\"User already exists\", STATUS.BAD_REQUEST);\r\n\r\n    let user;\r\n    if (existingUser) user = existingUser;\r\n    else {\r\n      user = await prisma.user.create({\r\n        data: {\r\n          name: userData.data.name,\r\n          email: userData.data.email,\r\n          password: \"\",\r\n          role: \"User\",\r\n        },\r\n      });\r\n    }\r\n\r\n    const jwtToken = createJWT(user);\r\n    if (!jwtToken)\r\n      throw new AppError(\r\n        \"Failed to create JWT token\",\r\n        STATUS.INTERNAL_SERVER_ERROR\r\n      );\r\n\r\n    response.send({\r\n      message: \"User logged in successfully\",\r\n      data: user,\r\n      token: jwtToken,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst registerUser: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { email, password, name, age, username } = request.body;\r\n\r\n    const exisitingUser = await prisma.user.findUnique({\r\n      where: {\r\n        email: email || null,\r\n      },\r\n    });\r\n\r\n    if (exisitingUser)\r\n      throw new AppError(\"User already exists\", STATUS.BAD_REQUEST);\r\n\r\n    const existingUsername = await prisma.user.findUnique({\r\n      where: {\r\n        username: username || null,\r\n      },\r\n    });\r\n\r\n    if (existingUsername)\r\n      throw new AppError(\"Username already exists\", STATUS.BAD_REQUEST);\r\n\r\n    const hashPassword = await bcrypt.hash(password, 10);\r\n\r\n    if (!age || age < 0) throw new AppError(\"Invalid age\", STATUS.BAD_REQUEST);\r\n\r\n    const newUser = await prisma.user.create({\r\n      data: {\r\n        email,\r\n        password: hashPassword,\r\n        name,\r\n        age,\r\n        username,\r\n        hearts: 3,\r\n        streak: 0,\r\n        membership: {\r\n          create: {\r\n            type: \"Free\",\r\n            status: \"Inactive\",\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    const jwtToken = createJWT(newUser);\r\n    if (!jwtToken)\r\n      throw new AppError(\r\n        \"Failed to create JWT token\",\r\n        STATUS.INTERNAL_SERVER_ERROR\r\n      );\r\n    response.send({\r\n      message: \"User created successfully\",\r\n      data: newUser,\r\n      token: jwtToken,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst loginUser: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { username, password } = request.body;\r\n    if (!username || !password) {\r\n      throw new AppError(\r\n        \"Username and password are required\",\r\n        STATUS.BAD_REQUEST\r\n      );\r\n    }\r\n\r\n    const user = await prisma.user.findUnique({\r\n      where: {\r\n        username: username,\r\n      },\r\n    });\r\n\r\n    if (!user) throw new AppError(\"User not found\", STATUS.NOT_FOUND);\r\n\r\n    const isPasswordValid = await bcrypt.compare(password, user.password);\r\n    if (!isPasswordValid)\r\n      throw new AppError(\"Invalid password\", STATUS.UNAUTHORIZED);\r\n\r\n    const jwtToken = createJWT(user);\r\n    if (!jwtToken)\r\n      throw new AppError(\r\n        \"Failed to create JWT token\",\r\n        STATUS.INTERNAL_SERVER_ERROR\r\n      );\r\n    response.send({\r\n      message: \"User logged in successfully\",\r\n      data: user,\r\n      token: jwtToken,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nexport default { registerUser, loginGoogle, loginUser };\r\n","import { User } from \"@prisma/client\";\r\nimport { JWT_SECRET } from \"../config/config\";\r\nimport jwt from \"jsonwebtoken\";\r\n\r\nexport const createJWT = (userData: User) => {\r\n  const tokenPayload = {\r\n    id: userData.id,\r\n    email: userData.email,\r\n    role: userData.role || \"user\",\r\n  };\r\n\r\n  return jwt.sign(tokenPayload, JWT_SECRET, { expiresIn: \"1d\" });\r\n};\r\n","import { RequestHandler } from \"express\";\r\nimport { AppError } from \"../utils/http/AppError\";\r\nimport { STATUS } from \"../utils/http/statusCodes\";\r\nimport { prisma } from \"../config/config\";\r\n\r\nconst createStory: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { title, regionId, originalText, englishText, vocab } = request.body;\r\n    // const requesterId = request.body.payload.id;\r\n    // const requester = await prisma.user.findUnique({\r\n    //   where: {\r\n    //     id: requesterId,\r\n    //   },\r\n    // });\r\n    // if (!requester || requester.role !== \"Admin\")\r\n    //   throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n\r\n    if (!title)\r\n      throw new AppError(\"Story title is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!regionId)\r\n      throw new AppError(\"Region ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!originalText)\r\n      throw new AppError(\"Original text is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!englishText)\r\n      throw new AppError(\"English text is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (vocab) {\r\n      if (!Array.isArray(vocab)) {\r\n        throw new AppError(\"Vocabularies must be an array\", STATUS.BAD_REQUEST);\r\n      }\r\n      for (const vocabularies of vocab) {\r\n        if (\r\n          !vocabularies.vocabText ||\r\n          !vocabularies.translatedText ||\r\n          !vocabularies.pronouncation\r\n        ) {\r\n          throw new AppError(\r\n            \"Each vocabulary entry must have vocabText, translatedText, and pronouncation\",\r\n            STATUS.BAD_REQUEST\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    const existingRegion = await prisma.region.findUnique({\r\n      where: {\r\n        id: regionId,\r\n      },\r\n    });\r\n\r\n    if (!existingRegion)\r\n      throw new AppError(\"Region not found\", STATUS.NOT_FOUND);\r\n\r\n    const storyData = await prisma.story.create({\r\n      data: {\r\n        title,\r\n        regionId,\r\n        originalText,\r\n        englishText,\r\n        vocab: {\r\n          create: vocab.map(\r\n            (vocabEntry: {\r\n              vocabText: string;\r\n              translatedText: string;\r\n              pronouncation: string;\r\n            }) => ({\r\n              vocabText: vocabEntry.vocabText,\r\n              translatedText: vocabEntry.translatedText,\r\n              pronouncation: vocabEntry.pronouncation,\r\n              regionId,\r\n            })\r\n          ),\r\n        },\r\n      },\r\n      include: {\r\n        vocab: true,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Story created successfully\",\r\n      data: storyData,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst editStory: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n    if (!id) throw new AppError(\"Story ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    const { title, regionId, originalText, englishText, vocab } = request.body;\r\n\r\n    // const requesterId = request.body.payload.id;\r\n    // const requester = await prisma.user.findUnique({\r\n    //   where: {\r\n    //     id: requesterId,\r\n    //   },\r\n    // });\r\n    // if (!requester || requester.role !== \"Admin\")\r\n    //   throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n\r\n    if (!title)\r\n      throw new AppError(\"Story title is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!regionId)\r\n      throw new AppError(\"Region ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!originalText)\r\n      throw new AppError(\"Original text is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!englishText)\r\n      throw new AppError(\"English text is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (vocab) {\r\n      if (!Array.isArray(vocab)) {\r\n        throw new AppError(\"Vocabularies must be an array\", STATUS.BAD_REQUEST);\r\n      }\r\n      for (const vocabularies of vocab) {\r\n        if (\r\n          !vocabularies.vocabText ||\r\n          !vocabularies.translatedText ||\r\n          !vocabularies.pronouncation\r\n        ) {\r\n          throw new AppError(\r\n            \"Each vocabulary entry must have vocabText, translatedText, and pronouncation\",\r\n            STATUS.BAD_REQUEST\r\n          );\r\n        }\r\n      }\r\n    }\r\n    const existingStory = await prisma.story.findUnique({\r\n      where: {\r\n        id: id,\r\n      },\r\n    });\r\n    if (!existingStory) throw new AppError(\"Story not found\", STATUS.NOT_FOUND);\r\n    const existingRegion = await prisma.region.findUnique({\r\n      where: {\r\n        id: regionId,\r\n      },\r\n    });\r\n    if (!existingRegion)\r\n      throw new AppError(\"Region not found\", STATUS.NOT_FOUND);\r\n    const updatedStory = await prisma.story.update({\r\n      where: {\r\n        id: id,\r\n      },\r\n      data: {\r\n        title: title ?? existingStory.title,\r\n        regionId: regionId ?? existingStory.regionId,\r\n        originalText: originalText ?? existingStory.originalText,\r\n        englishText: englishText ?? existingStory.englishText,\r\n        // Update vocab if provided the id, otherwise create new vocab\r\n        vocab: vocab\r\n          ? {\r\n              upsert: vocab.map(\r\n                (vocabEntry: {\r\n                  id?: string;\r\n                  vocabText: string;\r\n                  translatedText: string;\r\n                  pronouncation: string;\r\n                }) => ({\r\n                  where: {\r\n                    id: vocabEntry.id ?? \"\",\r\n                  },\r\n                  update: {\r\n                    vocabText: vocabEntry.vocabText,\r\n                    translatedText: vocabEntry.translatedText,\r\n                    pronouncation: vocabEntry.pronouncation,\r\n                    regionId: regionId ?? existingStory.regionId,\r\n                  },\r\n                  create: {\r\n                    vocabText: vocabEntry.vocabText,\r\n                    translatedText: vocabEntry.translatedText,\r\n                    pronouncation: vocabEntry.pronouncation,\r\n                    regionId: regionId ?? existingStory.regionId,\r\n                  },\r\n                })\r\n              ),\r\n            }\r\n          : undefined,\r\n      },\r\n      include: {\r\n        vocab: true,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Story updated successfully\",\r\n      data: updatedStory,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getStory: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const stories = await prisma.story.findMany({\r\n      orderBy: {\r\n        createdAt: \"desc\",\r\n      },\r\n      include: {\r\n        region: true,\r\n      },\r\n    });\r\n\r\n    if (!stories || stories.length === 0)\r\n      throw new AppError(\"No stories found\", STATUS.NOT_FOUND);\r\n\r\n    response.send({\r\n      message: \"Stories retrieved successfully\",\r\n      data: stories,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getStoryById: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n    if (!id) throw new AppError(\"Story ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    const story = await prisma.story.findUnique({\r\n      where: {\r\n        id: id,\r\n      },\r\n      include: {\r\n        region: true,\r\n        vocab: true,\r\n      },\r\n    });\r\n\r\n    if (!story) throw new AppError(\"Story not found\", STATUS.NOT_FOUND);\r\n\r\n    response.send({\r\n      message: \"Story retrieved successfully\",\r\n      data: story,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst deleteStory: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n    if (!id) throw new AppError(\"Story ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    // const requesterId = request.body.payload.id;\r\n    // const requester = await prisma.user.findUnique({\r\n    //   where: {\r\n    //     id: requesterId,\r\n    //   },\r\n    // });\r\n    // if (!requester || requester.role !== \"Admin\")\r\n    //   throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n\r\n    const existingStory = await prisma.story.findUnique({\r\n      where: {\r\n        id: id,\r\n      },\r\n    });\r\n    if (!existingStory) throw new AppError(\"Story not found\", STATUS.NOT_FOUND);\r\n\r\n    await prisma.story.delete({\r\n      where: {\r\n        id: id,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Story deleted successfully\",\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nexport default { createStory, editStory, getStory, getStoryById, deleteStory };\r\n","import { RequestHandler } from \"express\";\r\nimport { STATUS } from \"../utils/http/statusCodes\";\r\nimport { AppError } from \"../utils/http/AppError\";\r\nimport { prisma } from \"../config/config\";\r\n\r\nconst createRegion: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { name } = request.body;\r\n    if (!name) {\r\n      throw new AppError(\"Region name is required\", STATUS.BAD_REQUEST);\r\n    }\r\n\r\n    const regionData = await prisma.region.create({\r\n      data: {\r\n        name,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Region created successfully\",\r\n      data: regionData,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst editRegion: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n    if (!id) throw new AppError(\"Region ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    const { name } = request.body;\r\n    if (!name)\r\n      throw new AppError(\"Region name is required\", STATUS.BAD_REQUEST);\r\n\r\n    const requesterId = request.body.payload.id;\r\n    const requester = await prisma.user.findUnique({\r\n      where: {\r\n        id: requesterId,\r\n      },\r\n    });\r\n\r\n    if (!requester || requester.role !== \"Admin\")\r\n      throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n\r\n    const existingRegion = await prisma.region.findUnique({\r\n      where: {\r\n        id: id,\r\n      },\r\n    });\r\n\r\n    if (!existingRegion)\r\n      throw new AppError(\"Region not found\", STATUS.NOT_FOUND);\r\n\r\n    const updateRegion = await prisma.region.update({\r\n      where: {\r\n        id: id,\r\n      },\r\n      data: {\r\n        name: name,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Region updated successfully\",\r\n      data: updateRegion,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst deleteRegion: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n    if (!id) throw new AppError(\"Region ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    const requesterId = request.body.payload.id;\r\n    const requester = await prisma.user.findUnique({\r\n      where: {\r\n        id: requesterId,\r\n      },\r\n    });\r\n\r\n    if (!requester || requester.role !== \"Admin\")\r\n      throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n\r\n    const existingRegion = await prisma.region.findUnique({\r\n      where: {\r\n        id: id,\r\n      },\r\n    });\r\n\r\n    if (!existingRegion)\r\n      throw new AppError(\"Region not found\", STATUS.NOT_FOUND);\r\n\r\n    const deleteRegion = await prisma.region.delete({\r\n      where: {\r\n        id: id,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Region deleted successfully\",\r\n      data: deleteRegion,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getRegions: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const regions = await prisma.region.findMany({\r\n      orderBy: {\r\n        name: \"desc\",\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Regions retrieved successfully\",\r\n      data: regions,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getRegionById: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n    if (!id) throw new AppError(\"Region ID is required\", STATUS.BAD_REQUEST);\r\n    const region = await prisma.region.findUnique({\r\n      where: {\r\n        id: id,\r\n      },\r\n    });\r\n    if (!region) throw new AppError(\"Region not found\", STATUS.NOT_FOUND);\r\n    response.send({\r\n      message: \"Region retrieved successfully\",\r\n      data: region,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nexport default {\r\n  createRegion,\r\n  editRegion,\r\n  deleteRegion,\r\n  getRegions,\r\n  getRegionById,\r\n};\r\n","import { RequestHandler } from \"express\";\r\nimport { STATUS } from \"../utils/http/statusCodes\";\r\nimport { AppError } from \"../utils/http/AppError\";\r\nimport { prisma } from \"../config/config\";\r\n\r\nconst createVocab: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { vocabText, translatedText, pronouncation, regionId } = request.body;\r\n    if (!vocabText)\r\n      throw new AppError(\"Vocab text is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!translatedText)\r\n      throw new AppError(\"Translated text is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!pronouncation)\r\n      throw new AppError(\"Pronouncation is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!regionId)\r\n      throw new AppError(\"Region ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    const requesterId = request.body.payload.id;\r\n    const requester = await prisma.user.findUnique({\r\n      where: {\r\n        id: requesterId,\r\n      },\r\n    });\r\n\r\n    if (!requester || requester.role !== \"Admin\")\r\n      throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n\r\n    const existingRegion = await prisma.region.findUnique({\r\n      where: {\r\n        id: regionId,\r\n      },\r\n    });\r\n\r\n    if (!existingRegion)\r\n      throw new AppError(\"Region not found\", STATUS.NOT_FOUND);\r\n\r\n    const vocabData = await prisma.vocabulary.create({\r\n      data: {\r\n        vocabText,\r\n        translatedText,\r\n        pronouncation,\r\n        regionId,\r\n      },\r\n    });\r\n    response.send({\r\n      message: \"Vocabulary created successfully\",\r\n      data: vocabData,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst editVocab: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n    if (!id) throw new AppError(\"Vocab ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    const { vocabText, translatedText, pronouncation, regionId } = request.body;\r\n    if (!vocabText)\r\n      throw new AppError(\"Vocab text is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!translatedText)\r\n      throw new AppError(\"Translated text is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!pronouncation)\r\n      throw new AppError(\"Pronouncation is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!regionId)\r\n      throw new AppError(\"Region ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    const requesterId = request.body.payload.id;\r\n    const requester = await prisma.user.findUnique({\r\n      where: {\r\n        id: requesterId,\r\n      },\r\n    });\r\n\r\n    if (!requester || requester.role !== \"Admin\")\r\n      throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n\r\n    const existingRegion = await prisma.region.findUnique({\r\n      where: {\r\n        id: regionId,\r\n      },\r\n    });\r\n\r\n    if (!existingRegion)\r\n      throw new AppError(\"Region not found\", STATUS.NOT_FOUND);\r\n\r\n    const vocabData = await prisma.vocabulary.create({\r\n      data: {\r\n        vocabText,\r\n        translatedText,\r\n        pronouncation,\r\n        regionId,\r\n      },\r\n    });\r\n    response.send({\r\n      message: \"Vocabulary created successfully\",\r\n      data: vocabData,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getVocab: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const vocabData = await prisma.vocabulary.findMany({\r\n      include: {\r\n        region: true,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Vocab retrieved successfully\",\r\n      data: vocabData,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getVocabByRegion: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { regionId } = request.params;\r\n    if (!regionId)\r\n      throw new AppError(\"Region ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    const vocabData = await prisma.vocabulary.findMany({\r\n      where: {\r\n        regionId: regionId,\r\n      },\r\n      include: {\r\n        region: true,\r\n      },\r\n    });\r\n\r\n    if (vocabData.length === 0) {\r\n      throw new AppError(\"No vocab found for this region\", STATUS.NOT_FOUND);\r\n    }\r\n\r\n    response.send({\r\n      message: \"Vocab retrieved successfully\",\r\n      data: vocabData,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst deleteVocab: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n    if (!id) throw new AppError(\"Vocab ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    const requesterId = request.body.payload.id;\r\n    const requester = await prisma.user.findUnique({\r\n      where: {\r\n        id: requesterId,\r\n      },\r\n    });\r\n\r\n    if (!requester || requester.role !== \"Admin\")\r\n      throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n\r\n    const existingVocab = await prisma.vocabulary.findUnique({\r\n      where: {\r\n        id: id,\r\n      },\r\n    });\r\n\r\n    if (!existingVocab) throw new AppError(\"Vocab not found\", STATUS.NOT_FOUND);\r\n\r\n    await prisma.vocabulary.delete({\r\n      where: {\r\n        id: id,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Vocab deleted successfully\",\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nexport default {\r\n  createVocab,\r\n  editVocab,\r\n  getVocab,\r\n  getVocabByRegion,\r\n  deleteVocab,\r\n};\r\n","import { RequestHandler } from \"express\";\r\nimport { prisma } from \"../config/config\";\r\nimport { STATUS } from \"../utils/http/statusCodes\";\r\nimport { AppError } from \"../utils/http/AppError\";\r\n\r\n// Create Question\r\nconst createQuestion: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { text, type, subChapterId, questionOrder, answers, vocab } =\r\n      request.body;\r\n\r\n    // const requesterId = request.body.payload.id;\r\n\r\n    // const requester = await prisma.user.findUnique({\r\n    //   where: {\r\n    //     id: requesterId,\r\n    //   },\r\n    // });\r\n\r\n    // if (!requester || requester.role !== \"Admin\")\r\n    //   throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n\r\n    if (!text)\r\n      throw new AppError(\"Question text is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!type || ![\"Text\", \"Speech\"].includes(type))\r\n      throw new AppError(\r\n        \"Valid question type (Text or Speech) is required\",\r\n        STATUS.BAD_REQUEST\r\n      );\r\n\r\n    if (!subChapterId)\r\n      throw new AppError(\"SubChapter ID is required\", STATUS.BAD_REQUEST);\r\n\r\n    if (!questionOrder || questionOrder < 1)\r\n      throw new AppError(\r\n        \"Valid question order is required\",\r\n        STATUS.BAD_REQUEST\r\n      );\r\n\r\n    if (!answers || !Array.isArray(answers) || answers.length < 1)\r\n      throw new AppError(\"At least one answer is required\", STATUS.BAD_REQUEST);\r\n\r\n    let correctAnswerCount = 0;\r\n    for (const answer of answers) {\r\n      if (!answer.text) {\r\n        throw new AppError(\"Each answer must have text\", STATUS.BAD_REQUEST);\r\n      }\r\n      if (answer.isCorrect) correctAnswerCount++;\r\n    }\r\n    if (correctAnswerCount !== 1) {\r\n      throw new AppError(\r\n        \"Exactly one answer must be correct\",\r\n        STATUS.BAD_REQUEST\r\n      );\r\n    }\r\n\r\n    // Validate vocab array if provided\r\n    if (vocab) {\r\n      if (!Array.isArray(vocab)) {\r\n        throw new AppError(\"Vocabularies must be an array\", STATUS.BAD_REQUEST);\r\n      }\r\n      for (const vocabEntry of vocab) {\r\n        if (\r\n          !vocabEntry.vocabText ||\r\n          !vocabEntry.translatedText ||\r\n          !vocabEntry.pronunciation\r\n        ) {\r\n          throw new AppError(\r\n            \"Each vocabulary entry must have vocabText, translatedText, and pronunciation\",\r\n            STATUS.BAD_REQUEST\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check if subChapter exists\r\n    const existingSubChapter = await prisma.subChapter.findUnique({\r\n      where: {\r\n        id: subChapterId,\r\n      },\r\n      include: {\r\n        chapter: {\r\n          include: {\r\n            story: {\r\n              include: {\r\n                region: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    if (!existingSubChapter)\r\n      throw new AppError(\"SubChapter not found\", STATUS.NOT_FOUND);\r\n\r\n    const questionData = await prisma.question.create({\r\n      data: {\r\n        text,\r\n        type,\r\n        subChapterId,\r\n        questionOrder,\r\n        answer: {\r\n          create: answers.map(\r\n            (answer: { text: string; isCorrect: boolean }) => ({\r\n              text: answer.text,\r\n              isCorrect: answer.isCorrect,\r\n            })\r\n          ),\r\n        },\r\n        vocab: {\r\n          create: vocab?.map(\r\n            (vocabEntry: {\r\n              vocabText: string;\r\n              translatedText: string;\r\n              pronunciation: string;\r\n            }) => ({\r\n              vocabText: vocabEntry.vocabText,\r\n              translatedText: vocabEntry.translatedText,\r\n              pronunciation: vocabEntry.pronunciation,\r\n              regionId: existingSubChapter.chapter.story.regionId,\r\n            })\r\n          ),\r\n        },\r\n      },\r\n      include: {\r\n        answer: true,\r\n        vocab: true,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Question created successfully\",\r\n      data: questionData,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getQuestionById: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n\r\n    const question = await prisma.question.findUnique({\r\n      where: {\r\n        id,\r\n      },\r\n      include: {\r\n        answer: true,\r\n        vocab: true,\r\n      },\r\n    });\r\n    if (!question) throw new AppError(\"Question not found\", STATUS.NOT_FOUND);\r\n\r\n    response.send({\r\n      message: \"Question retrieved successfully\",\r\n      data: question,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst getAllQuestion: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const questions = await prisma.question.findMany({\r\n      include: {\r\n        subChapter: {\r\n          include: {\r\n            chapter: {\r\n              include: {\r\n                story: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        answer: true,\r\n        vocab: true,\r\n      },\r\n      orderBy: {\r\n        questionOrder: \"asc\",\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Questions retrieved successfully\",\r\n      data: questions,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst updateQuestion: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n    const { text, type, questionOrder } = request.body;\r\n\r\n    // const requesterId = request.body.payload.id;\r\n\r\n    // const requester = await prisma.user.findUnique({\r\n    //   where: {\r\n    //     id: requesterId,\r\n    //   },\r\n    // });\r\n    // if (!requester || requester.role !== \"Admin\") {\r\n    //   throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n    // }\r\n\r\n    const question = await prisma.question.findUnique({\r\n      where: {\r\n        id,\r\n      },\r\n    });\r\n\r\n    if (!question) throw new AppError(\"Question not found\", STATUS.NOT_FOUND);\r\n\r\n    if (!text && !type && !questionOrder)\r\n      throw new AppError(\r\n        \"At least one field (text, type, or questionOrder) is required\",\r\n        STATUS.BAD_REQUEST\r\n      );\r\n\r\n    if (type && ![\"Text\", \"Speech\"].includes(type))\r\n      throw new AppError(\r\n        \"Valid question type (Text or Speech) is required\",\r\n        STATUS.BAD_REQUEST\r\n      );\r\n\r\n    if (questionOrder && questionOrder < 1)\r\n      throw new AppError(\r\n        \"Valid question order is required\",\r\n        STATUS.BAD_REQUEST\r\n      );\r\n\r\n    const updatedQuestion = await prisma.question.update({\r\n      where: {\r\n        id,\r\n      },\r\n      data: {\r\n        text: text || question.text,\r\n        type: type || question.type,\r\n        questionOrder: questionOrder || question.questionOrder,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Question updated successfully\",\r\n      data: updatedQuestion,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nconst deleteQuestion: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    const { id } = request.params;\r\n    // const requesterId = request.body.payload.id;\r\n\r\n    // const requester = await prisma.user.findUnique({\r\n    //   where: {\r\n    //     id: requesterId,\r\n    //   },\r\n    // });\r\n    // if (!requester || requester.role !== \"Admin\") {\r\n    //   throw new AppError(\"Unauthorized\", STATUS.UNAUTHORIZED);\r\n    // }\r\n\r\n    const question = await prisma.question.findUnique({\r\n      where: {\r\n        id,\r\n      },\r\n    });\r\n\r\n    if (!question) throw new AppError(\"Question not found\", STATUS.NOT_FOUND);\r\n\r\n    await prisma.question.delete({\r\n      where: {\r\n        id,\r\n      },\r\n    });\r\n\r\n    response.send({\r\n      message: \"Question deleted successfully\",\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nexport default {\r\n  createQuestion,\r\n  getQuestionById,\r\n  getAllQuestion,\r\n  updateQuestion,\r\n  deleteQuestion,\r\n};\r\n","import { Router } from \"express\";\r\nimport { RegionController } from \"../controllers\";\r\n\r\n\r\nconst regionRouter = Router();\r\n\r\nregionRouter.get(\"/region\", RegionController.getRegions);\r\nregionRouter.post(\"/region\", RegionController.createRegion);\r\nregionRouter.post(\"/region/update/:id\", RegionController.editRegion);\r\nregionRouter.post(\"/region/delete/:id\", RegionController.deleteRegion);\r\n\r\nexport default regionRouter;\r\n","import { Router } from \"express\";\r\nimport { StoryController } from \"../controllers\";\r\n\r\n\r\nconst storyRouter = Router();\r\n\r\nstoryRouter.get(\"/story\", StoryController.getStory);\r\nstoryRouter.get(\"/story/:id\", StoryController.getStoryById);\r\nstoryRouter.post(\"/story\", StoryController.createStory);\r\nstoryRouter.post(\"/story/update/:id\", StoryController.editStory);\r\nstoryRouter.post(\"/story/delete/:id\", StoryController.deleteStory);\r\n\r\nexport default storyRouter;\r\n","import { Router } from \"express\";\r\nimport { vocabController } from \"../controllers\";\r\n\r\nconst vocabRouter = Router();\r\n\r\nvocabRouter.get(\"/vocab\", vocabController.getVocab);\r\nvocabRouter.get(\"/vocab/:regionId\", vocabController.getVocabByRegion);\r\nvocabRouter.post(\"/vocab/create\", vocabController.createVocab);\r\nvocabRouter.post(\"/vocab/edit/:id\", vocabController.editVocab);\r\n\r\nexport default vocabRouter;\r\n","import { Router } from \"express\";\r\nimport { questionController } from \"../controllers\";\r\n\r\nconst questionRouter = Router();\r\n\r\nquestionRouter.get(\"/question\", questionController.getAllQuestion);\r\nquestionRouter.get(\"/question/:id\", questionController.getQuestionById);\r\n// questionRouter.get(\"/question/:id\", questionController.getQuestionById);\r\nquestionRouter.post(\"/question\", questionController.createQuestion);\r\nquestionRouter.post(\"/update/question/:id\", questionController.updateQuestion);\r\nquestionRouter.post(\"/delete/question/:id\", questionController.deleteQuestion);\r\n\r\nexport default questionRouter;\r\n","import { Router } from \"express\";\r\nimport { vocal } from \"../controllers\";\r\nimport vocalController from \"../controllers/vocalController\";\r\nimport multer from \"multer\";\r\n\r\nconst vocalRouter = Router();\r\nconst upload = multer({ dest: \"uploads/\" });\r\n\r\nvocalRouter.post(\r\n  \"/checkVocal\",\r\n  upload.single(\"audio\"),\r\n  vocalController.checkPronounciation\r\n);\r\n\r\nexport default vocalRouter;\r\n","import { RequestHandler } from \"express\";\r\nimport axios from \"axios\";\r\nimport fs from \"fs-extra\";\r\nimport { AppError } from \"../utils/http/AppError\";\r\nimport OpenAI from \"openai\";\r\nconst baseUrl = \"https://api.assemblyai.com\";\r\n\r\nconst headers = {\r\n  authorization: process.env.ASSEMBLY_API_KEY,\r\n};\r\n\r\nconst openai = new OpenAI({\r\n  apiKey: process.env.OPENAI_API_KEY,\r\n});\r\n\r\nconst checkPronounciation: RequestHandler = async (request, response, next) => {\r\n  try {\r\n    if (!request.file) {\r\n      throw new AppError(\"No audio file uploaded\", 400);\r\n    }\r\n    const filePath = request.file.path;\r\n    const originalText = request.body.ori;\r\n    const audioData = await fs.readFile(filePath);\r\n\r\n    // Upload to AssemblyAI\r\n    const uploadResponse = await axios.post(`${baseUrl}/v2/upload`, audioData, {\r\n      headers: {\r\n        ...headers,\r\n        \"Content-Type\": \"application/octet-stream\",\r\n      },\r\n    });\r\n    const audioUrl = uploadResponse.data.upload_url;\r\n\r\n    const data = {\r\n      audio_url: audioUrl,\r\n      speech_model: \"universal\",\r\n      language_code: \"jw\", // Javanese may not be supported; try auto-detect\r\n    };\r\n\r\n    const transcriptResponse = await axios.post(\r\n      `${baseUrl}/v2/transcript`,\r\n      data,\r\n      { headers }\r\n    );\r\n    const transcriptId = transcriptResponse.data.id;\r\n    const pollingEndpoint = `${baseUrl}/v2/transcript/${transcriptId}`;\r\n\r\n    const pollTranscription = async () => {\r\n      while (true) {\r\n        const pollingResponse = await axios.get(pollingEndpoint, { headers });\r\n        const transcriptionResult = pollingResponse.data;\r\n\r\n        if (transcriptionResult.status === \"completed\") {\r\n          return transcriptionResult.text;\r\n        } else if (transcriptionResult.status === \"error\") {\r\n          throw new Error(transcriptionResult.error);\r\n        }\r\n        await new Promise((resolve) => setTimeout(resolve, 3000));\r\n      }\r\n    };\r\n\r\n    const textTranscription = await pollTranscription();\r\n    await fs.remove(filePath); // Clean up temp file\r\n\r\n    // OPEN AI\r\n    const openaiApiKey = process.env.OPENAI_API_KEY;\r\n    if (!openaiApiKey) {\r\n      throw new AppError(\"OpenAI API key is not set\", 500);\r\n    }\r\n\r\n    const openAIResponse = await openai.chat.completions.create({\r\n      model: \"gpt-4o-mini\",\r\n      messages: [\r\n        {\r\n          role: \"user\",\r\n          content: [\r\n            {\r\n              type: \"text\",\r\n              text:\r\n                `Fi am currently learning speaking javanese, this is the text that I am reading\\n\\n` +\r\n                originalText +\r\n                \"So i read it and use an AI to transcribe it and returne\\n\\n\" +\r\n                textTranscription +\r\n                `\\n\\n please rate how my speaking out of 100 and give me one sentence on my performance like how well i do, please dont be too harsh. return and limit your response in a json format where\\n\\n` +\r\n                `{\r\n                    \"score\": number\r\n                    \"comments\": string \r\n                     \r\n                  }\r\n                  return without any further quotation just direct json format`,\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n      temperature: 1,\r\n      max_tokens: 2048,\r\n      top_p: 1,\r\n    });\r\n    const scorings = await openAIResponse.choices[0].message.content;\r\n\r\n    if (!scorings) {\r\n      throw new AppError(\"No scoring received from AI\", 500);\r\n    }\r\n    response.send({\r\n      message: \"Scored successfully\",\r\n      data: scorings,\r\n    });\r\n  } catch (error) {\r\n    next(error);\r\n  }\r\n};\r\n\r\nexport default { checkPronounciation };\r\n","export const PORT = process.env.PORT || \"\";\r\n"],"mappings":"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","names":["chalk","express","cors","Router","Router","AppError","_AppError","message","statusCode","IS_PRODUCTION","errorHandler","error","_","response","__","AppError","ErrorController_default","PrismaClient","prisma","JWT_SECRET","JWT_EXPIRES_IN","STATUS","bcrypt","jwt","createJWT","userData","tokenPayload","JWT_SECRET","axios","loginGoogle","request","response","next","token","AppError","STATUS","userData","existingUser","prisma","user","jwtToken","createJWT","error","registerUser","email","password","name","age","username","hashPassword","bcrypt","newUser","loginUser","AuthController_default","createStory","request","response","next","title","regionId","originalText","englishText","vocab","AppError","STATUS","vocabularies","prisma","storyData","vocabEntry","error","editStory","id","existingStory","updatedStory","getStory","stories","getStoryById","story","deleteStory","StoryController_default","createRegion","request","response","next","name","AppError","STATUS","regionData","prisma","error","editRegion","id","requesterId","requester","updateRegion","deleteRegion","getRegions","regions","getRegionById","region","RegionController_default","createVocab","request","response","next","vocabText","translatedText","pronouncation","regionId","AppError","STATUS","requesterId","requester","prisma","vocabData","error","editVocab","id","getVocab","getVocabByRegion","deleteVocab","vocabController_default","createQuestion","request","response","next","text","type","subChapterId","questionOrder","answers","vocab","AppError","STATUS","correctAnswerCount","answer","vocabEntry","existingSubChapter","prisma","questionData","error","getQuestionById","id","question","getAllQuestion","questions","updateQuestion","updatedQuestion","deleteQuestion","questionController_default","authRouter","Router","AuthController_default","authRouter_default","Router","regionRouter","Router","RegionController_default","regionRouter_default","Router","storyRouter","Router","StoryController_default","storyRouter_default","Router","vocabRouter","Router","vocabController_default","vocabRouter_default","Router","questionRouter","Router","questionController_default","questionRouter_default","Router","axios","fs","OpenAI","baseUrl","headers","openai","checkPronounciation","request","response","next","AppError","filePath","originalText","audioData","fs","data","axios","transcriptId","pollingEndpoint","textTranscription","transcriptionResult","resolve","scorings","error","vocalController_default","multer","vocalRouter","Router","upload","vocalController_default","vocalRouter_default","router","Router","_","response","authRouter_default","regionRouter_default","storyRouter_default","vocabRouter_default","questionRouter_default","vocalRouter_default","routes_default","app","express","cors","routes_default","_","__","next","AppError","STATUS","ErrorController_default","app_default","PORT","app_default","PORT","chalk"]}